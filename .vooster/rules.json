{
  "rules": [
    {
      "type": "prd",
      "content": "## 제품 요구 사항 문서 (PRD)\n\n### 1. Introduction\n\n이 문서는 프리랜서가 플랫폼에 의존하지 않고,\n직접적인 영업을 통해 잠재 고객에게 제안서를 작성·발송하며\n클라이언트를 확보할 수 있도록 실행 과정을 돕는\n시스템의 요구 사항을 설명합니다.\n\n### 2. Goals\n\n* 프리랜서가 플랫폼 외부에서 클라이언트를 확보할 수 있도록 지원\n* 사용자가 최소 제안서를 단계별로 완성하고 실제 발송까지 도달하게 함\n* 클라이언트 확보를 위한 체계적인 접근 방식 제공\n\n### 3. Target Audience\n\n경력 2년 미만의 프리랜서\n최소 1건 이상의 유료 프로젝트 경험이 있는 프리랜서\n플랫폼 기반 클라이언트 확보에서 벗어나고자 하는 프리랜서\n제안서 작성 및 아웃바운드 영업에 익숙하지 않은 프리랜서\n\n### 4. Key Features\n\n***기업 기반 제안서 완성 플로우**\n  - 선택된 기업 1곳을 기준으로 최소 제안서를 단계별로 완성하는 기능\n  - 각 단계에서 사용자가 먼저 생각을 입력하고,\n    AI는 해당 생각을 제안서 문장으로 정리하는 역할만 수행\n  - 최종 결과는 “보내도 되는 수준”의 제안서 텍스트\n\n***잠재고객 선별 및 확인 워크플로우**\n  - 사용자가 직접 입력한 후보를 기준으로\n    오늘 제안해도 무리하지 않은 대상인지 점검하는 과정\n  - AI는 판단이 아닌 확인과 언어화 역할만 수행\n  - 최종 선택 책임은 사용자에게 있음\n\n***하루 단위 행동 기록**\n  - 오늘의 제안 대상과 제안서 상태를 기록\n  - 실제 발송 후 “보냈다” 행동을 남김\n  - 분석이나 성과 관리가 아닌,\n    하루의 행동 완료 여부만 표시\n\n\n### 5. User Stories\n\n- 프리랜서로서, 무엇부터 해야 할지 고민하지 않고 제안할 1곳에 맞는 제안 구조를 만들고 싶습니다.\n- 프리랜서로서, 플랫폼에 의존하지 않고 제안할 수 있는 잠재 고객을 찾아내고 싶습니다.\n- 프리랜서로서, 아무것도 안 한 하루를 반복하지 않도록 행동을 기록하고 싶습니다.\n\n\n### 6. Release Criteria\n\n사용자가 잠재 고객 선택 → 제안서 완성 → 실제 발송까지의\n실행 과정을 최소 1회 이상 완료할 수 있을 것\n\n### 7. Development Strategy\n\n핵심 기능 중심의 최소 요건 제품(MVP) 개발\n가설 검증과 반복적 개선에 중점을 둔 린 스타트업 방식 적용\n### 8. Success Metrics\n\n* 최소 1회 이상 제안서 발송까지 도달한 사용자 비율\n* 제안서 완성 → 발송까지 이어진 전환율\n* 고객 확보 사례 수 (정성)\n\n\n### 9. Future Considerations\n\n* 본 제품은 개인 프리랜서의 첫 제안 실행에 집중하며,\n  자동화, CRM, 커뮤니티 기능은\n  향후 별도 검증 후 고려할 수 있다.\n\n\n### 10. Risks and Challenges\n\n* 사용자가 제안서 작성 단계에서 이탈할 가능성\n* 잠재고객 선별 기준에 대한 신뢰 형성\n* 초기 성공 경험을 빠르게 만들어내고 성공 사례 창출\n",
      "writedAt": "2026-01-15T11:27:04.562Z"
    },
    {
      "type": "architecture",
      "content": "```markdown\n# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **Project Overview**: 본 프로젝트는 Next.js 프레임워크를 사용하여 프론트엔드를 개발하고, Supabase를 백엔드 및 인증 시스템으로 활용하며, Toss Payments API를 통해 결제 기능을 통합하는 웹 애플리케이션입니다. 목표는 프리랜서가 플랫폼 의존성을 벗어나 직접 고객을 확보할 수 있도록 14일 시스템을 제공하는 것입니다.\n- **Core Technology Stack**: Next.js, Supabase, Supabase Auth, Toss Payments를 핵심 기술 스택으로 사용합니다.\n- **Key Technical Objectives**: 사용자 경험 최적화, 높은 시스템 가용성, 데이터 보안 강화, 확장 가능한 아키텍처 구축을 목표로 합니다.\n- **Critical Technical Assumptions**: 안정적인 인터넷 연결, Supabase 및 Toss Payments API의 안정적인 서비스 제공, 사용자 교육 및 지원 자료 제공을 전제로 합니다.\n\n## 2. Tech Stack\n\n| Category          | Technology / Library        | Reasoning (Why it's chosen for this project) |\n| ----------------- | --------------------------- | -------------------------------------------- |\n| 프레임워크        | Next.js                     | 서버 사이드 렌더링 (SSR) 및 정적 사이트 생성 (SSG) 지원, 뛰어난 성능, SEO 최적화, 개발 생산성 향상 |\n| 백엔드            | Supabase                    | PostgreSQL 기반의 BaaS (Backend as a Service), 실시간 데이터베이스, 인증, 스토리지 등 다양한 기능 제공, 빠른 개발 속도, 확장성 |\n| 인증              | Supabase Auth               | 간편한 사용자 인증 및 관리, 소셜 로그인 지원, 보안 강화 |\n| 결제              | Toss Payments               | 다양한 결제 수단 지원, 간편한 결제 API, 보안 강화, PG사 연동 간소화 |\n| 데이터베이스      | PostgreSQL (Supabase)       | 안정성, 확장성, ACID 트랜잭션 지원, 다양한 데이터 타입 지원 |\n| 배포              | Vercel / Netlify           | Next.js에 최적화된 배포 플랫폼, 자동 배포, CDN 지원, 간편한 설정 |\n| 상태 관리         | React Context API / Zustand | 간단한 상태 관리, 컴포넌트 간 데이터 공유 용이, 불필요한 복잡성 제거 |\n| UI 라이브러리     | Tailwind CSS                | 빠른 UI 개발, 유지보수 용이, 반응형 디자인 지원 |\n\n## 3. System Architecture Design\n\n### Top-Level building blocks\n- **Frontend (Next.js)**: 사용자 인터페이스 및 사용자 경험을 담당합니다.\n    - 컴포넌트: 페이지 컴포넌트, UI 컴포넌트, 상태 관리 컴포넌트\n    - 기능: 사용자 인터랙션 처리, API 호출, 데이터 렌더링\n- **Backend (Supabase)**: 데이터베이스, 인증, 스토리지 등 백엔드 로직을 담당합니다.\n    - 컴포넌트: 데이터베이스 스키마, API 엔드포인트, 인증 로직\n    - 기능: 데이터 저장 및 관리, 사용자 인증 및 권한 관리, 파일 저장 및 관리\n- **Payment (Toss Payments)**: 결제 처리를 담당합니다.\n    - 컴포넌트: 결제 API, 결제 위젯\n    - 기능: 결제 요청 처리, 결제 결과 처리, 결제 취소 처리\n\n### Top-Level Component Interaction Diagram\n\n```mermaid\ngraph TD\n    A[Frontend (Next.js)] --> B[Backend (Supabase)]\n    A --> C[Payment (Toss Payments)]\n    B --> D[Database (PostgreSQL)]\n```\n\n- **Frontend (Next.js) <-> Backend (Supabase)**: 프론트엔드는 API를 통해 백엔드에 데이터를 요청하고 응답을 받습니다. 사용자 인증, 데이터 저장, 데이터 조회 등의 작업을 수행합니다.\n- **Frontend (Next.js) <-> Payment (Toss Payments)**: 프론트엔드는 Toss Payments API를 사용하여 결제 요청을 처리하고 결제 결과를 받습니다.\n- **Backend (Supabase) <-> Database (PostgreSQL)**: 백엔드는 PostgreSQL 데이터베이스에 데이터를 저장하고 관리합니다.\n- **Database (PostgreSQL)**: 모든 애플리케이션 데이터를 저장하고 관리합니다. 사용자 정보, 제안서 템플릿, 고객 정보, 진행 상황 등을 저장합니다.\n\n### Code Organization & Convention\n**Domain-Driven Organization Strategy**\n- **Domain Separation**: 사용자 관리, 제안서 생성, 고객 관리, 결제 처리 등의 도메인으로 코드를 분리합니다.\n- **Layer-Based Architecture**: 프레젠테이션 레이어 (UI 컴포넌트), 비즈니스 로직 레이어 (서비스), 데이터 접근 레이어 (Supabase API)로 분리합니다.\n- **Feature-Based Modules**: 각 기능별로 모듈을 구성하여 관련 파일들을 함께 관리합니다.\n- **Shared Components**: 공통적으로 사용되는 유틸리티 함수, 타입 정의, UI 컴포넌트 등을 공유 모듈에 저장합니다.\n\n**Universal File & Folder Structure**\n```\n/\n├── components/           # UI 컴포넌트\n│   ├── proposal/         # 제안서 관련 컴포넌트\n│   │   ├── ProposalForm.tsx\n│   │   └── ProposalTemplate.tsx\n│   ├── customer/         # 고객 관련 컴포넌트\n│   │   ├── CustomerList.tsx\n│   │   └── CustomerCard.tsx\n│   └── shared/           # 공통 컴포넌트\n│       ├── Button.tsx\n│       └── Input.tsx\n├── pages/                # Next.js 페이지\n│   ├── index.tsx          # 메인 페이지\n│   ├── proposal.tsx       # 제안서 생성 페이지\n│   ├── customers.tsx      # 고객 관리 페이지\n│   └── payment.tsx        # 결제 페이지\n├── services/             # 비즈니스 로직\n│   ├── proposalService.ts\n│   ├── customerService.ts\n│   └── paymentService.ts\n├── utils/                # 유틸리티 함수\n│   ├── api.ts             # API 요청 함수\n│   └── helpers.ts         # 기타 유틸리티 함수\n├── types/                # 타입 정의\n│   ├── proposal.ts\n│   ├── customer.ts\n│   └── payment.ts\n├── supabase/             # Supabase 관련 설정\n│   ├── client.ts          # Supabase 클라이언트 초기화\n│   └── types.ts           # Supabase 타입 정의\n├── public/               # 정적 파일\n│   ├── images/\n│   └── ...\n├── .env.local            # 환경 변수\n├── next.config.js        # Next.js 설정\n└── tsconfig.json         # TypeScript 설정\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server Communication**: 프론트엔드는 API 요청을 통해 백엔드와 통신합니다. RESTful API를 사용하여 데이터를 주고받습니다.\n- **Database Interaction**: Supabase 클라이언트를 사용하여 데이터베이스에 접근하고 데이터를 CRUD (Create, Read, Update, Delete) 합니다.\n- **External Service Integration**: Toss Payments API를 사용하여 결제 기능을 통합합니다. API 키를 안전하게 관리하고 오류 처리를 꼼꼼하게 수행합니다.\n- **Data Synchronization**: 실시간 데이터 업데이트가 필요한 경우 Supabase Realtime을 사용하여 데이터 동기화를 구현합니다.\n\n## 4. Performance & Optimization Strategy\n\n- **Code Splitting**: Next.js의 Code Splitting 기능을 활용하여 초기 로딩 시간을 줄입니다.\n- **Image Optimization**: 이미지 최적화 도구를 사용하여 이미지 크기를 줄이고 로딩 속도를 향상시킵니다.\n- **Caching**: Supabase의 캐싱 기능을 활용하여 데이터베이스 쿼리 성능을 향상시킵니다.\n- **Lazy Loading**: 필요할 때만 리소스를 로딩하여 초기 로딩 시간을 줄입니다.\n\n## 5. Implementation Roadmap & Milestones\n### Phase 1: Foundation (MVP Implementation)\n- **Core Infrastructure**: Next.js 프로젝트 설정, Supabase 연동, Toss Payments 연동, 기본 UI 구성\n- **Essential Features**: 제안서 템플릿 생성 기능, 고객 정보 관리 기능, 진행 상황 추적 기능\n- **Basic Security**: 사용자 인증 및 권한 관리, 데이터베이스 보안 설정\n- **Development Setup**: 개발 환경 설정, CI/CD 파이프라인 구축\n- **Timeline**: 4주\n\n### Phase 2: Feature Enhancement\n- **Advanced Features**: 자동 제안서 발송 기능, CRM 연동 기능, 고급 보고서 기능, 커뮤니티 기능\n- **Performance Optimization**: 시스템 성능 개선, 데이터베이스 쿼리 최적화, 캐싱 전략 강화\n- **Enhanced Security**: 보안 취약점 점검 및 개선, 보안 감사 수행\n- **Monitoring Implementation**: 시스템 모니터링 및 로깅 시스템 구축\n- **Timeline**: 8주\n\n## 6. Risk Assessment & Mitigation Strategies\n### Technical Risk Analysis\n- **Technology Risks**: Next.js, Supabase, Toss Payments API 사용 중 발생할 수 있는 기술적 문제 및 의존성 문제\n    - **Mitigation Strategies**: 각 기술 스택에 대한 충분한 학습 및 경험 확보, 공식 문서 및 커뮤니티 활용, 문제 발생 시 빠른 해결을 위한 기술 지원 체계 구축\n- **Performance Risks**: 사용자 증가에 따른 시스템 성능 저하 및 확장성 문제\n    - **Mitigation Strategies**: 부하 테스트 수행, 데이터베이스 쿼리 최적화, 캐싱 전략 적용, 필요 시 서버 확장\n- **Security Risks**: 사용자 정보 유출, 데이터 변조, 해킹 시도 등 보안 취약점\n    - **Mitigation Strategies**: 보안 감사 수행, 정기적인 보안 업데이트, 강력한 암호화 알고리즘 사용, 접근 권한 관리 강화, XSS, CSRF 방어\n\n### Project Delivery Risks\n- **Timeline Risks**: 개발 일정 지연, 예상치 못한 기술적 문제 발생\n    - **Contingency Plans**: 우선순위가 높은 기능부터 개발, 애자일 개발 방법론 적용, 정기적인 코드 리뷰 및 테스트 수행, 예비 개발 인력 확보\n- **Resource Risks**: 개발 인력 부족, 기술 전문가 부족\n    - **Contingency Plans**: 추가 개발 인력 확보, 외부 전문가 활용, 팀 내 기술 공유 및 교육 강화\n- **Quality Risks**: 코드 품질 저하, 버그 발생, 사용자 불만 증가\n    - **Contingency Plans**: 코드 리뷰 의무화, 단위 테스트 및 통합 테스트 수행, 사용자 피드백 적극 수용, 버그 수정 및 개선 작업 지속 수행\n- **Deployment Risks**: 배포 과정 중 오류 발생, 시스템 중단\n    - **Contingency Plans**: 배포 전 충분한 테스트 수행, 자동 배포 시스템 구축, 배포 후 모니터링 강화, 롤백 전략 준비\n```",
      "writedAt": "2026-01-15T11:27:04.562Z"
    },
    {
      "type": "guideline",
      "content": "# Code Guideline\n\n---\n\n## General Principles\n- Write clear, readable, and maintainable code.\n- Follow the Single Responsibility Principle.\n- Document complex logic with concise comments.\n\n---\n\n## MUST Rules\n- MUST use TypeScript for all new code.\n- MUST write unit tests for all logic components.\n- MUST use meaningful variable and function names.\n\n---\n\n## MUST NOT Rules\n- MUST NOT use `any` type in TypeScript except where unavoidable.\n- MUST NOT commit code with lint or type errors.\n\n---\n\n## Naming Conventions\n- Variables and functions: camelCase\n- Classes and types: PascalCase\n- Constants: SCREAMING_SNAKE_CASE\n\n---\n\n## Error Handling\n- Always handle errors gracefully and log exceptions.\n- Do not expose sensitive error messages to end-users.\n\n---\n\n## Testing Standards\n- All new features must include unit and integration tests.\n- Use Jest as the default testing framework.\n\n---\n\n## Performance Guidelines\n- Avoid unnecessary re-renders in React components.\n- Optimize loops and data processing for large datasets.\n\n---\n\n## Security Practices\n- Never commit secrets or credentials.\n- Use parameterized queries for all database access.\n\n---\n\n## Example\n```typescript\n// Good Example\nfunction calculateSum(a: number, b: number): number {\n  return a + b;\n}\n```\n---\n",
      "writedAt": "2026-01-15T11:27:04.562Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2026-01-15T11:27:04.562Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2026-01-15T11:27:04.562Z"
    }
  ]
}